# 基础知识

## 一、Android 应用测试基础知识

### 测试的益处

测试是应用开发流程中不可或缺的一环。通过持续对应用运行测试，您可以在公开发布应用之前验证其正确性、功能行为和易用性。

您可以浏览应用，*手动* 测试应用。您可能会使用不同的设备和模拟器、更改系统语言，并尝试**生成**每个用户错误或**遍历**每个用户流程。

不过，手动测试的可扩展性较差，并且很容易忽略应用行为中的回归。*自动化测试* 是指使用可为您执行测试的**工具**，这种方式速度更快、可重复性更高，并且通常会在开发过程的早期阶段为您提供更多有关应用的实用反馈。

### Android 中的测试类型

移动应用非常复杂，必须在多种环境中正常运行。因此，测试类型有很多种。

- 怎么听起来，像是，放屁，呢。。。。。。

#### 主题

例如，根据*主题*，测试类型各不相同：

- **功能测试**：我的应用是否能正常运行？
- **性能测试**：是否快速高效？
- **无障碍功能测试**：应用是否能与无障碍服务良好搭配使用？
- **兼容性测试**：它在每个设备和 API 级别上都能正常运行吗？

#### 范围

测试也会因*大小*或*隔离程度*而异：

- **单元测试**或**小型测试**仅验证应用的一小部分，例如方法或类。
- **端到端**测试或**大型测试**可同时验证应用的较大部分，例如整个屏幕或用户流程。
- **中型测试**介于两者之间，用于检查两个或更多单元之间的**集成**。

测试的分类方式有很多。不过，对于应用开发者来说，**最重要**的区别在于**测试的运行位置**。

### 插桩测试与本地测试

您可以在 Android 设备上或**另一台计算机**上运行测试：

- **插桩测试**：在 Android 设备（实体设备或模拟设备）上运行。**该应用**与注入命令并读取状态的**测试应用** 一起构建和安装。插桩测试通常是界面测试，会启动应用，然后与之互动。
  - 所以，是有两个应用？一个应用是当前代码执行的，东西？叫做YOU，一个应用，是来用测试它的？叫他FUCK，所以一次组成FUCK YOU。
- **本地测试**：在开发**机器**或**服务器**上执行，因此也称为*主机端测试*。它们通常很小且速度很快，可将被测对象与应用的其余部分隔离开来。

![](.\image\instru-vs-local.png)

并非所有单元测试都是本地测试，也并非所有端到端测试都在设备上运行。例如：

- **大型本地测试**：您可以使用在本地运行的 Android 模拟器，例如 [Robolectric](https://developer.android.com/training/testing/local-tests/robolectric?hl=zh-cn)。
- **小型插桩测试**：您可以验证代码是否能与框架功能（例如 SQLite 数据库）良好配合。您可以在多部设备上运行此测试，以检查与多个版本的 SQLite 的集成。
  - 搞这种，数据库的，读写，挺好、挺好

#### 示例

以下代码段演示了如何在*插桩界面测试*中与界面互动，点击某个元素并验证是否显示了另一个元素。

```kotlin
// When the Continue button is clicked
onView(withText("Continue"))
    .perform(click())

// Then the Welcome screen is displayed
onView(withText("Welcome"))
    .check(matches(isDisplayed()))
```

此代码段展示了 ViewModel（本地、主机端测试）的部分*单元测试*：

```kotlin
// Given an instance of MyViewModel
val viewModel = MyViewModel(myFakeDataRepository)

// When data is loaded
viewModel.loadData()

// Then it should be exposing data
assertTrue(viewModel.data != null)
```

### 可测试的架构

借助**可测试的应用架构**，代码遵循一种结构，让您可以轻松单独测试代码的不同部分。可测试的架构还具有其他优势，例如可读性、可维护性、可伸缩性和可重用性更强。

*无法测试*的架构会产生以下结果：

- 测试规模更大、速度更慢、不稳定程度更高。无法进行单元测试的类可能需要通过更大的集成测试或界面测试来覆盖。
- 测试不同场景的机会较少。测试范围越大，速度越慢，因此测试应用的所有可能状态可能不太现实。
  - 不知道，我们当前这个架构，是不是，不好，呢，嘿嘿嘿嘿嘿

如需详细了解架构指南，请参阅[应用架构指南](https://developer.android.com/jetpack/guide?hl=zh-cn)。

#### 解耦方法

如果您能将函数、类或模块的**一部分**从其余部分中提取出来，那么测试起来会更轻松、更有效。这种做法称为解耦，是可测试架构中最重要的概念。

常见的解耦技术包括：

- 将应用拆分为多个*层*，例如表示层、网域层和数据层。您还可以将应用拆分为多个*模块*，每个模块对应一项功能。
- 避免向具有较大依赖项（例如 activity 和 fragment）的实体添加逻辑。使用这些类作为框架的**入口点**，并将 *界面和业务逻辑* 移至其他位置，例如移至可组合项、ViewModel 或网域层。
- 避免在包含业务逻辑的类中直接使用*框架依赖项*。 例如，[请勿在 ViewModel 中使用 Android Context](https://medium.com/androiddevelopers/locale-changes-and-the-androidviewmodel-antipattern-84eb677660d9)。
  - 哼哼哼，不就是，官网，提出的，东西，神气个，JB，啊
- 使依赖项易于*替换*。例如，使用[接口](https://en.wikipedia.org/wiki/Interface_segregation_principle)而不是具体实现。即使您不使用 DI 框架，也要使用[依赖项注入](https://developer.android.com/training/dependency-injection?hl=zh-cn)。
  - 老生常谈，但是，又真的，做到了？似乎，并没有，呢。



## 二、要在 Android 中测试的内容

您应该测试的内容取决于**应用类型**、开发团队、旧版代码的数量和使用的架构等因素。以下各部分概述了新手在规划在应用中测试哪些内容时可能需要考虑的事项。

### 测试目录的组织方式

Android Studio 中的典型项目包含**两个目录**，用于存储测试的执行环境。请按照说明，在以下目录中整理测试：

- `androidTest` 目录应包含在**真实或虚拟设备上运行的测试**。此类测试包括**集成测试、端到端测试**，以及仅靠 JVM 无法验证应用功能的其他测试。
- `test` 目录应包含在本地计算机上运行的测试，如**单元测试**。与上述方法不同，这些测试可以是在**本地 JVM 上运行的测试**。

### 基本单元测试

在遵循最佳实践时，您应确保在下列情况下使用单元测试：

- 针对 **ViewModel** 或 Presenter 的**单元测试**。
- 针对**数据层**（尤其是代码库）的**单元测试**。大部分数据层都应**独立于平台**。这样做可让测试替身替换测试中的数据库模块和远程数据源。请参阅有关[在 Android 中使用测试替身](https://developer.android.com/training/testing/fundamentals/test-doubles?hl=zh-cn)的指南
- 针对其他独立于平台的层（例如**网域**层），针对用例和交互器进行**单元测试**。
- 针对**实用程序类**（例如**字符串操作和数学**）的**单元测试**。

#### 测试极端情况

单元测试应同时关注**正常情况和极端情况**。极端情况很少见，真人测试人员和大型测试不太可能发现。示例包括：

- 使用负数、零和[边界条件](https://en.wikipedia.org/wiki/Off-by-one_error)的数学运算。
- 所有可能的**网络连接错误**。
  - 这个好，把network测试测试
- 数据损坏，例如格式错误的 JSON。
  - 这个也不错，故意，写错一些数据结构，让load去调用
- 保存到文件时模拟已满存储空间。
- 在进程过程中重新创建的对象（例如旋转设备时的 activity）。
